<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Valentine Card</title>
  <meta name="description" content="Valentine">
  <meta name="author" content="RafaÅ‚ Kruk">
  <!-- Styles -->
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      height: 100dvh; /* Use dynamic viewport height for mobile */
      background-color: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      height: 100dvh; /* Use dynamic viewport height for mobile */
    }
  </style>
</head>
<body>
  <div id="main">
    <canvas></canvas>
    <script>
      // Performance optimized Valentine card - same visuals, better code
      (function() {
        'use strict';
        
        const canvas = document.getElementsByTagName('canvas')[0];
        const ctx = canvas.getContext('2d');
        const particles = [];
        const heartPoints = [];
        const TWO_PI = Math.PI * 2;
        
        let canvasWidth, canvasHeight;
        let animationId;
        let particleCount, trailLength;
        
        // Cached math functions for better performance
        const { random: rand, cos, sin, sqrt, pow, floor } = Math;
        
        function resizeCanvas() {
          const dpr = window.devicePixelRatio || 1;
          
          // For mobile, use actual viewport dimensions
          const actualWidth = window.innerWidth;
          const actualHeight = window.innerHeight;
          
          // Set canvas size to actual viewport
          canvas.width = actualWidth * dpr;
          canvas.height = actualHeight * dpr;
          
          // Scale canvas context for high-DPI
          ctx.scale(dpr, dpr);
          
          // Set CSS size to actual viewport
          canvas.style.width = actualWidth + 'px';
          canvas.style.height = actualHeight + 'px';
          
          // Use actual dimensions for calculations
          canvasWidth = actualWidth;
          canvasHeight = actualHeight;
          
          // Update particle counts based on current screen size
          const isMobile = actualWidth < 768;
          particleCount = isMobile ? 16 : 32;
          trailLength = isMobile ? 16 : 32;
          
          // Calculate responsive heart size - much smaller for mobile
          const heartScale = Math.min(canvasWidth, canvasHeight) * (isMobile ? 0.25 : 0.4);
          
          // Regenerate heart points with proper centering
          heartPoints.length = 0;
          for (let i = 0; i < 6.3; i += 0.2) {
            heartPoints.push([
              canvasWidth / 2 + heartScale * pow(sin(i), 3),
              canvasHeight / 2 - heartScale * 0.8 * (15 * cos(i) - 5 * cos(2 * i) - 2 * cos(3 * i) - cos(4 * i)) / 16
            ]);
          }
        }
        
        function initParticles() {
          particles.length = 0;
          
          for (let i = 0; i < particleCount; i++) {
            const x = rand() * canvasWidth;
            const y = rand() * canvasHeight;
            const hue = 80 * (i / particleCount) + 280;
            const saturation = 40 * rand() + 60;
            const brightness = 60 * rand() + 20;
            
            const trail = [];
            for (let k = 0; k < trailLength; k++) {
              trail[k] = {
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                size: 1 - k / trailLength + 1,
                speed: rand() + 1,
                targetIndex: floor(rand() * heartPoints.length),
                direction: 2 * (i % 2) - 1,
                friction: 0.2 * rand() + 0.7,
                color: `hsla(${floor(hue)},${floor(saturation)}%,${floor(brightness)}%,.1)`
              };
            }
            particles[i] = trail;
          }
        }
        
        function drawParticle(particle) {
          ctx.fillStyle = particle.color;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, TWO_PI, true);
          ctx.closePath();
          ctx.fill();
        }
        
        function updateAndDraw() {
          // Clear canvas with fade effect
          ctx.fillStyle = "rgba(0,0,0,.2)";
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          
          // Update particles
          for (let i = particleCount - 1; i >= 0; i--) {
            const trail = particles[i];
            const head = trail[0];
            const target = heartPoints[head.targetIndex];
            
            if (target) {
              const dx = head.x - target[0];
              const dy = head.y - target[1];
              const distance = sqrt(dx * dx + dy * dy);
              
              // Target switching logic
              if (distance < 10) {
                if (rand() > 0.95) {
                  head.targetIndex = floor(rand() * heartPoints.length);
                } else {
                  if (rand() > 0.99) head.direction *= -1;
                  head.targetIndex += head.direction;
                  head.targetIndex %= heartPoints.length;
                  if (head.targetIndex < 0) head.targetIndex += heartPoints.length;
                }
              }
              
              // Apply forces
              head.vx += -dx / distance * head.speed;
              head.vy += -dy / distance * head.speed;
            }
            
            // Update head position
            head.x += head.vx;
            head.y += head.vy;
            drawParticle(head);
            
            // Apply friction
            head.vx *= head.friction;
            head.vy *= head.friction;
            
            // Update trail
            for (let k = 0; k < trailLength - 1; k++) {
              const current = trail[k];
              const next = trail[k + 1];
              next.x -= 0.7 * (next.x - current.x);
              next.y -= 0.7 * (next.y - current.y);
              drawParticle(next);
            }
          }
        }
        
        function animate() {
          updateAndDraw();
          setTimeout(() => {
            if (animationId) {
              animationId = requestAnimationFrame(animate);
            }
          }, 25);
        }
        
        function handleResize() {
          resizeCanvas();
          initParticles();
        }
        
        // Debounced resize handler for better performance
        let resizeTimeout;
        function debouncedResize() {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(handleResize, 100);
        }
        
        function handleVisibilityChange() {
          if (document.hidden) {
            if (animationId) {
              cancelAnimationFrame(animationId);
              animationId = null;
            }
          } else {
            if (!animationId) {
              animationId = requestAnimationFrame(animate);
            }
          }
        }
        
        // Initialize
        resizeCanvas();
        initParticles();
        animationId = requestAnimationFrame(animate);
        
        // Event listeners
        window.addEventListener('resize', debouncedResize);
        document.addEventListener('visibilitychange', handleVisibilityChange);
        
        // Cleanup function (in case needed)
        window.valentineCleanup = function() {
          if (animationId) cancelAnimationFrame(animationId);
          if (resizeTimeout) clearTimeout(resizeTimeout);
          window.removeEventListener('resize', debouncedResize);
          document.removeEventListener('visibilitychange', handleVisibilityChange);
        };
      })();
    </script>
  </div>
</body>
</html>

